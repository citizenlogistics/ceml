# Autogenerated from a Treetop grammar. Edits may be lost.


module CEML
module Instructions
  include Treetop::Runtime

  def root
    @root ||= :basic_statement
  end

  include Lexer

  module BasicStatement0

    def delay
        if parent.respond_to? :later and not parent.later.empty?
            parent.later.duration.seconds
        end
    end

    def role;  id.text_value.to_sym; end
    def text;  defined?(super) && super; end
    def var
        return varname.text_value if cmd == :record or cmd == :set or cmd == :release
        (!respond_to?(:about) || about.empty?) ? nil : about.varname.text_value;
    end
    def key;   var || text; end
    def cmd;  text_value.split.first.to_sym; end
    def cond
        (!respond_to?(:condition) || condition.empty?) ? nil : condition.value
    end

    def bytecode
        code = []
        code.concat   [[[role], :start_delay, delay],
                       [[role], :complete_delay]] if delay
        code.concat case cmd
        when :record;  [[[role], :answered_q,      {:key  => key}]]
        when :set;     [[[role], :set,             {:key  => key, :value => text}]]
        when :pick;    [[[role], :pick,            {:key  => key, :value => text}]]
        when :seed;    [[[role], :seed,            {:target => var, :role => role}]]
        when :ask;     [[[role], :ask_q,           {:text => text}],
                        [[role], :answered_q,      {:key  => key}]]
        when :tell;    [[[role], :send_msg,        {:text => text}]]
        when :assign;  [[[role], :assign,          {:text => text}],
                        [[role], :complete_assign, {:text => text}]]
        when :release; [[[role], :release,         {:tag  => key, :cond => cond}]]
        when :sync;    [[[role], :sync,            {:role => role}]]
        end
        code
    end
  end

  def _nt_basic_statement
    start_index = index
    if node_cache[:basic_statement].has_key?(index)
      cached = node_cache[:basic_statement][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_ask_stmt
    if r1
      r0 = r1
      r0.extend(BasicStatement0)
    else
      r2 = _nt_tell_stmt
      if r2
        r0 = r2
        r0.extend(BasicStatement0)
      else
        r3 = _nt_assign_stmt
        if r3
          r0 = r3
          r0.extend(BasicStatement0)
        else
          r4 = _nt_record_stmt
          if r4
            r0 = r4
            r0.extend(BasicStatement0)
          else
            r5 = _nt_set_stmt
            if r5
              r0 = r5
              r0.extend(BasicStatement0)
            else
              r6 = _nt_pick_stmt
              if r6
                r0 = r6
                r0.extend(BasicStatement0)
              else
                r7 = _nt_seed_stmt
                if r7
                  r0 = r7
                  r0.extend(BasicStatement0)
                else
                  r8 = _nt_sync_stmt
                  if r8
                    r0 = r8
                    r0.extend(BasicStatement0)
                  else
                    r9 = _nt_replace_stmt
                    if r9
                      r0 = r9
                      r0.extend(BasicStatement0)
                    else
                      r10 = _nt_release_stmt
                      if r10
                        r0 = r10
                        r0.extend(BasicStatement0)
                      else
                        @index = i0
                        r0 = nil
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end

    node_cache[:basic_statement][start_index] = r0

    r0
  end

  module InstructionStmt0
    def later
      elements[0]
    end

    def basic_statement
      elements[1]
    end
  end

  def _nt_instruction_stmt
    start_index = index
    if node_cache[:instruction_stmt].has_key?(index)
      cached = node_cache[:instruction_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_later
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_basic_statement
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(InstructionStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:instruction_stmt][start_index] = r0

    r0
  end

  module Later0
    def duration
      elements[0]
    end

    def ws1
      elements[1]
    end

    def ws2
      elements[3]
    end
  end

  def _nt_later
    start_index = index
    if node_cache[:later].has_key?(index)
      cached = node_cache[:later][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_duration
    s0 << r1
    if r1
      r2 = _nt_ws
      s0 << r2
      if r2
        if has_terminal?('later', false, index)
          r3 = instantiate_node(SyntaxNode,input, index...(index + 5))
          @index += 5
        else
          terminal_parse_failure('later')
          r3 = nil
        end
        s0 << r3
        if r3
          r4 = _nt_ws
          s0 << r4
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Later0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:later][start_index] = r0

    r0
  end

  module SeedStmt0
    def ws1
      elements[1]
    end

    def varname
      elements[2]
    end

    def ws2
      elements[3]
    end

    def ws3
      elements[5]
    end

    def rolename
      elements[6]
    end
  end

  def _nt_seed_stmt
    start_index = index
    if node_cache[:seed_stmt].has_key?(index)
      cached = node_cache[:seed_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('seed', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure('seed')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_ws
      s0 << r2
      if r2
        r3 = _nt_id
        s0 << r3
        if r3
          r4 = _nt_ws
          s0 << r4
          if r4
            if has_terminal?('with', false, index)
              r5 = instantiate_node(SyntaxNode,input, index...(index + 4))
              @index += 4
            else
              terminal_parse_failure('with')
              r5 = nil
            end
            s0 << r5
            if r5
              r6 = _nt_ws
              s0 << r6
              if r6
                r7 = _nt_id
                s0 << r7
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(SeedStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:seed_stmt][start_index] = r0

    r0
  end

  module RecordStmt0
    def ws1
      elements[1]
    end

    def id
      elements[2]
    end

    def ws2
      elements[3]
    end

    def varname
      elements[4]
    end
  end

  def _nt_record_stmt
    start_index = index
    if node_cache[:record_stmt].has_key?(index)
      cached = node_cache[:record_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('record', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure('record')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_ws
      s0 << r2
      if r2
        r3 = _nt_id
        s0 << r3
        if r3
          r4 = _nt_ws
          s0 << r4
          if r4
            r5 = _nt_id
            s0 << r5
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(RecordStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:record_stmt][start_index] = r0

    r0
  end

  module TellStmt0
    def ws
      elements[1]
    end

    def id
      elements[2]
    end

    def text
      elements[5]
    end
  end

  def _nt_tell_stmt
    start_index = index
    if node_cache[:tell_stmt].has_key?(index)
      cached = node_cache[:tell_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('tell', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure('tell')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_ws
      s0 << r2
      if r2
        r3 = _nt_id
        s0 << r3
        if r3
          if has_terminal?(':', false, index)
            r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure(':')
            r4 = nil
          end
          s0 << r4
          if r4
            r6 = _nt_ws
            if r6
              r5 = r6
            else
              r5 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r5
            if r5
              r7 = _nt_text
              s0 << r7
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(TellStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:tell_stmt][start_index] = r0

    r0
  end

  module AssignStmt0
    def ws
      elements[1]
    end

    def id
      elements[2]
    end

    def text
      elements[5]
    end
  end

  def _nt_assign_stmt
    start_index = index
    if node_cache[:assign_stmt].has_key?(index)
      cached = node_cache[:assign_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('assign', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure('assign')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_ws
      s0 << r2
      if r2
        r3 = _nt_id
        s0 << r3
        if r3
          if has_terminal?(':', false, index)
            r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure(':')
            r4 = nil
          end
          s0 << r4
          if r4
            r6 = _nt_ws
            if r6
              r5 = r6
            else
              r5 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r5
            if r5
              r7 = _nt_text
              s0 << r7
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(AssignStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:assign_stmt][start_index] = r0

    r0
  end

  module AskStmt0
    def ws1
      elements[0]
    end

    def ws2
      elements[2]
    end

    def varname
      elements[3]
    end
  end

  module AskStmt1
    def ws
      elements[1]
    end

    def id
      elements[2]
    end

    def about
      elements[3]
    end

    def text
      elements[6]
    end
  end

  def _nt_ask_stmt
    start_index = index
    if node_cache[:ask_stmt].has_key?(index)
      cached = node_cache[:ask_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('ask', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 3))
      @index += 3
    else
      terminal_parse_failure('ask')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_ws
      s0 << r2
      if r2
        r3 = _nt_id
        s0 << r3
        if r3
          i5, s5 = index, []
          r6 = _nt_ws
          s5 << r6
          if r6
            if has_terminal?('re', false, index)
              r7 = instantiate_node(SyntaxNode,input, index...(index + 2))
              @index += 2
            else
              terminal_parse_failure('re')
              r7 = nil
            end
            s5 << r7
            if r7
              r8 = _nt_ws
              s5 << r8
              if r8
                r9 = _nt_id
                s5 << r9
              end
            end
          end
          if s5.last
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            r5.extend(AskStmt0)
          else
            @index = i5
            r5 = nil
          end
          if r5
            r4 = r5
          else
            r4 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r4
          if r4
            if has_terminal?(':', false, index)
              r10 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure(':')
              r10 = nil
            end
            s0 << r10
            if r10
              r12 = _nt_ws
              if r12
                r11 = r12
              else
                r11 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r11
              if r11
                r13 = _nt_text
                s0 << r13
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(AskStmt1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:ask_stmt][start_index] = r0

    r0
  end

  module SetStmt0
    def ws1
      elements[1]
    end

    def id
      elements[2]
    end

    def ws2
      elements[3]
    end

    def varname
      elements[4]
    end

    def text
      elements[7]
    end
  end

  def _nt_set_stmt
    start_index = index
    if node_cache[:set_stmt].has_key?(index)
      cached = node_cache[:set_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('set', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 3))
      @index += 3
    else
      terminal_parse_failure('set')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_ws
      s0 << r2
      if r2
        r3 = _nt_id
        s0 << r3
        if r3
          r4 = _nt_ws
          s0 << r4
          if r4
            r5 = _nt_id
            s0 << r5
            if r5
              if has_terminal?(':', false, index)
                r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure(':')
                r6 = nil
              end
              s0 << r6
              if r6
                r8 = _nt_ws
                if r8
                  r7 = r8
                else
                  r7 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r7
                if r7
                  r9 = _nt_text
                  s0 << r9
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(SetStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:set_stmt][start_index] = r0

    r0
  end

  module PickStmt0
    def ws1
      elements[1]
    end

    def id
      elements[2]
    end

    def ws2
      elements[3]
    end

    def varname
      elements[4]
    end

    def text
      elements[7]
    end
  end

  def _nt_pick_stmt
    start_index = index
    if node_cache[:pick_stmt].has_key?(index)
      cached = node_cache[:pick_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('pick', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure('pick')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_ws
      s0 << r2
      if r2
        r3 = _nt_id
        s0 << r3
        if r3
          r4 = _nt_ws
          s0 << r4
          if r4
            r5 = _nt_id
            s0 << r5
            if r5
              if has_terminal?(':', false, index)
                r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure(':')
                r6 = nil
              end
              s0 << r6
              if r6
                r8 = _nt_ws
                if r8
                  r7 = r8
                else
                  r7 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r7
                if r7
                  r9 = _nt_text
                  s0 << r9
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(PickStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:pick_stmt][start_index] = r0

    r0
  end

  module SyncStmt0
    def ws
      elements[1]
    end

    def id
      elements[2]
    end
  end

  def _nt_sync_stmt
    start_index = index
    if node_cache[:sync_stmt].has_key?(index)
      cached = node_cache[:sync_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('sync', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure('sync')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_ws
      s0 << r2
      if r2
        r3 = _nt_id
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(SyncStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sync_stmt][start_index] = r0

    r0
  end

  module ReleaseStmt0
    def ws1
      elements[1]
    end

    def id
      elements[2]
    end

    def ws2
      elements[3]
    end

    def ws3
      elements[5]
    end

    def varname
      elements[6]
    end

    def condition
      elements[7]
    end
  end

  def _nt_release_stmt
    start_index = index
    if node_cache[:release_stmt].has_key?(index)
      cached = node_cache[:release_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('release', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 7))
      @index += 7
    else
      terminal_parse_failure('release')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_ws
      s0 << r2
      if r2
        r3 = _nt_id
        s0 << r3
        if r3
          r4 = _nt_ws
          s0 << r4
          if r4
            if has_terminal?('as', false, index)
              r5 = instantiate_node(SyntaxNode,input, index...(index + 2))
              @index += 2
            else
              terminal_parse_failure('as')
              r5 = nil
            end
            s0 << r5
            if r5
              r6 = _nt_ws
              s0 << r6
              if r6
                r7 = _nt_id
                s0 << r7
                if r7
                  r9 = _nt_condition
                  if r9
                    r8 = r9
                  else
                    r8 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r8
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(ReleaseStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:release_stmt][start_index] = r0

    r0
  end

  module ReplaceStmt0
    def ws
      elements[1]
    end

    def id
      elements[2]
    end

    def condition
      elements[3]
    end
  end

  def _nt_replace_stmt
    start_index = index
    if node_cache[:replace_stmt].has_key?(index)
      cached = node_cache[:replace_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('replace', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 7))
      @index += 7
    else
      terminal_parse_failure('replace')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_ws
      s0 << r2
      if r2
        r3 = _nt_id
        s0 << r3
        if r3
          r5 = _nt_condition
          if r5
            r4 = r5
          else
            r4 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r4
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(ReplaceStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:replace_stmt][start_index] = r0

    r0
  end

  module Condition0
    def ws1
      elements[0]
    end

    def type
      elements[1]
    end

    def ws2
      elements[2]
    end

    def thing
      elements[3]
    end
  end

  module Condition1
    def value
        [type.text_value.to_sym, thing.text_value.to_sym]
    end
  end

  def _nt_condition
    start_index = index
    if node_cache[:condition].has_key?(index)
      cached = node_cache[:condition][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_ws
    s0 << r1
    if r1
      i2 = index
      if has_terminal?('if', false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 2))
        @index += 2
      else
        terminal_parse_failure('if')
        r3 = nil
      end
      if r3
        r2 = r3
      else
        if has_terminal?('unless', false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 6))
          @index += 6
        else
          terminal_parse_failure('unless')
          r4 = nil
        end
        if r4
          r2 = r4
        else
          @index = i2
          r2 = nil
        end
      end
      s0 << r2
      if r2
        r5 = _nt_ws
        s0 << r5
        if r5
          r6 = _nt_id
          s0 << r6
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Condition0)
      r0.extend(Condition1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:condition][start_index] = r0

    r0
  end

end

class InstructionsParser < Treetop::Runtime::CompiledParser
  include Instructions
end

end
